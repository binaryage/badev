// BaClassPrefix.h
//
// -------------------------------------------------------------------------------------------------------------------
//
//  This allows the same classes in different bundles to be used within the same process
//    without running into conflicts with class names in the ObjC runtime
//
//  All that is required is different definitions of BA_CLASS_PREFIX and use the macros BA_PREFIXED_CLASS,
//    BA_PREFIXED_INTERFACE and BA_PREFIXED_IMPLEMENTATION for interface and implementation declarations
//
// -------------------------------------------------------------------------------------------------------------------
//
//  Example:
//
//  somewhere BA_CLASS_PREFIX is defined as BATF
//
//    BA_PREFIXED_CLASS_SUPPORT(TotalFinder);
//    @interface BA_PREFIXED_CLASS(TotalFinder) : TotalFinderShell
//      ...
//    @end
//  OR
//    BA_PREFIXED_INTERFACE(TotalFinder, TotalFinderShell)
//      ...
//    @end
//
//    Since we would have wrapped TotalFinderShell with the macro in its definition, the classes resolve
//      to BATF_TotalFinder and BATF_TotalFinderShell
//
//    BA_PREFIXED_CLASS_SUPPORT() allows us to use a class' non-prefixed name in sources
//      so [TotalFinder sharedInstance] is perfectly legal
//
// -------------------------------------------------------------------------------------------------------------------

#import <objc/runtime.h>
#import <Foundation/Foundation.h>

#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif

#if !defined(FORCE_INLINE)
# if __has_attribute(always_inline)
#  define FORCE_INLINE __inline__ __attribute__((always_inline))
# else
#  define FORCE_INLINE __inline__
# endif
#endif

// Default prefix
#if !defined(BA_CLASS_PREFIX)
# define BA_CLASS_PREFIX <%= @project.prefix %>
#endif


#define BA_CLASS_PREFIX_QUOTE(x) #x
#define BA_CLASS_PREFIX_STRINGIFY(macro) BA_CLASS_PREFIX_QUOTE(macro)
#define BA_CLASS_PREFIX_JOIN(prefix, classname) prefix ## _ ## classname
#define BA_CLASS_PREFIX_JOIN_STR(prefix, classname) BA_CLASS_PREFIX_JOIN(prefix, classname)

// Prefix as string
#define BA_CLASS_PREFIX_STR BA_CLASS_PREFIX_STRINGIFY(BA_CLASS_PREFIX)

// Class token and stringified class name
#define BA_PREFIXED_CLASS(classname) BA_CLASS_PREFIX_JOIN_STR(BA_CLASS_PREFIX, classname)
#define BA_PREFIXED_CLASS_STR(classname) BA_CLASS_PREFIX_STRINGIFY(BA_PREFIXED_CLASS(classname))

// Forward declaration
#define BA_PREFIXED_CLASS_DECL(classname) \
  @class BA_PREFIXED_CLASS(classname);

// Compatibility alias
#define BA_PREFIXED_CLASS_ALIAS(classname) \
  @compatibility_alias classname BA_PREFIXED_CLASS(classname);

// Allows use of non-prefixed class tokens in sources
#define BA_PREFIXED_CLASS_SUPPORT(classname) \
  BA_PREFIXED_CLASS_DECL(classname) \
  BA_PREFIXED_CLASS_ALIAS(classname)

// Interface and support macros combined
#define BA_PREFIXED_INTERFACE(classname, superclass) \
  BA_PREFIXED_CLASS_SUPPORT(classname); \
  @interface BA_PREFIXED_CLASS(classname) : superclass

// Implementation macro
#define BA_PREFIXED_IMPLEMENTATION(classname) \
  @implementation BA_PREFIXED_CLASS(classname)

#undef NSClassFromString
#undef objc_getClass
#undef objc_lookUpClass

FORCE_INLINE Class BaClassPrefixClassFromString(NSString* classname, NSString* prefix) {
  if (!classname) return Nil;
  Class cls = NSClassFromString(classname);

  if (!cls && !prefix) return Nil;
  if (!cls) {
    cls = NSClassFromString([prefix stringByAppendingFormat:@"_%@", classname]);
  }
  if (!cls) {
    cls = NSClassFromString([prefix stringByAppendingFormat:@"%@", classname]);
  }
  return cls;
}

FORCE_INLINE Class BaClassPrefixGetClass(const char* classname, const char* prefix) {
  if (!classname) return Nil;
  Class cls = objc_getClass(classname);

  if (!cls && !prefix) return Nil;
  if (!cls) {
    cls = objc_getClass([[NSString stringWithFormat:@"%s_%s", prefix, classname] UTF8String]);
  }
  if (!cls) {
    cls = objc_getClass([[NSString stringWithFormat:@"%s%s", prefix, classname] UTF8String]);
  }
  return cls;
}

FORCE_INLINE Class BaClassPrefixLookupClass(const char* classname, const char* prefix) {
  if (!classname) return Nil;
  Class cls = objc_lookUpClass(classname);

  if (!cls && !prefix) return Nil;

  if (!cls) {
    cls = objc_lookUpClass([[NSString stringWithFormat:@"%s_%s", prefix, classname] UTF8String]);
  }
  if (!cls) {
    cls = objc_lookUpClass([[NSString stringWithFormat:@"%s%s", prefix, classname] UTF8String]);
  }
  return cls;
}

FORCE_INLINE Class _BaClassPrefixClassFromString(NSString* classname) {
  return BaClassPrefixClassFromString(classname, @ BA_CLASS_PREFIX_STR);
}

FORCE_INLINE Class _BaClassPrefixGetClass(const char* classname) {
  return BaClassPrefixGetClass(classname, BA_CLASS_PREFIX_STR);
}

FORCE_INLINE Class _BaClassPrefixLookupClass(const char* classname) {
  return BaClassPrefixLookupClass(classname, BA_CLASS_PREFIX_STR);
}

#define NSClassFromString _BaClassPrefixClassFromString
#define objc_getClass _BaClassPrefixGetClass
#define objc_lookUpClass _BaClassPrefixLookupClass